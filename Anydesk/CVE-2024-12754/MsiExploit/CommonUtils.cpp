//  Copyright 2015 Google Inc. All Rights Reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  http ://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

#include "stdafx.h"
#include "CommonUtils.h"
#include <strsafe.h>
#include "ntimports.h"

#include <string>      // std::string, std::wstring
#include <algorithm>   // std::copy  


bool DeleteDirectoryContents(LPWSTR dirPath) {
	WIN32_FIND_DATA findFileData;
	HANDLE hFind;

	LPWSTR searchPath = new wchar_t[wcslen(dirPath) + 3];
	swprintf_s(searchPath, wcslen(dirPath) + 3, L"%s\\*", dirPath);

	hFind = FindFirstFile(searchPath, &findFileData);
	if (hFind == INVALID_HANDLE_VALUE) {
		delete[] searchPath;
		return false;
	}

	do {
		LPWSTR fileOrDirName = findFileData.cFileName;

		if (wcscmp(fileOrDirName, L".") != 0 && wcscmp(fileOrDirName, L"..") != 0) {
			LPWSTR fullPath = new wchar_t[wcslen(dirPath) + wcslen(fileOrDirName) + 2];
			swprintf_s(fullPath, wcslen(dirPath) + wcslen(fileOrDirName) + 2, L"%s\\%s", dirPath, fileOrDirName);

			if (findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
				DeleteDirectoryContents(fullPath);
				RemoveDirectory(fullPath);
			}
			else {
				DeleteFile(fullPath);
			}

			delete[] fullPath;
		}
	} while (FindNextFile(hFind, &findFileData) != 0);

	FindClose(hFind);
	delete[] searchPath;
	return true;
}


bool RemoveDirectoryWithContents(LPWSTR dirPath) {
	if (!DeleteDirectoryContents(dirPath)) {
		// std::wcerr << L"Can't delete files in the dir: " << GetLastError() << std::endl;
		return false;
	}

	if (!RemoveDirectory(dirPath)) {
		//std::wcerr << L"Can't delete directory: " << GetLastError() << std::endl;
		return false;
	}

	return true;
}

std::wstring s2ws(const std::string& str)
{
	int size_needed = MultiByteToWideChar(CP_UTF8, 0, &str[0], (int)str.size(), NULL, 0);
	std::wstring wstrTo(size_needed, 0);
	MultiByteToWideChar(CP_UTF8, 0, &str[0], (int)str.size(), &wstrTo[0], size_needed);
	return wstrTo;
}

bool DoesFileExist(LPCWSTR lpszFilename)
{
	DWORD fileAttr = GetFileAttributes(lpszFilename);
	DWORD lastErr = GetLastError();
	return ((fileAttr != INVALID_FILE_ATTRIBUTES)
		&& (lastErr != ERROR_FILE_NOT_FOUND));
}

bool dirExists(LPCWSTR dirName_in)
{
	DWORD ftyp = GetFileAttributes(dirName_in);
	if (ftyp == INVALID_FILE_ATTRIBUTES)
		return false;  //something is wrong with your path!

	if (ftyp & FILE_ATTRIBUTE_DIRECTORY)
		return true;   // this is a directory!

	return false;    // this is not a directory!
}

HANDLE CreateSymlink(HANDLE root, LPCWSTR linkname, LPCWSTR targetname)
{
	DEFINE_NTDLL(RtlInitUnicodeString);
	DEFINE_NTDLL(NtCreateSymbolicLinkObject);

	OBJECT_ATTRIBUTES objAttr;
	UNICODE_STRING name;
	UNICODE_STRING target;

	fRtlInitUnicodeString(&name, linkname);
	fRtlInitUnicodeString(&target, targetname);

	InitializeObjectAttributes(&objAttr, &name, OBJ_CASE_INSENSITIVE, root, nullptr);

	HANDLE hLink;

	NTSTATUS status = fNtCreateSymbolicLinkObject(&hLink,
		SYMBOLIC_LINK_ALL_ACCESS, &objAttr, &target);
	if (status == 0)
	{
		//DebugPrintf("Opened Link %ls -> %ls: %p\n", linkname, targetname, hLink);
		return hLink;
	}
	else
	{
		SetLastError(NtStatusToDosError(status));
		return nullptr;
	}
}

std::wstring StringToWString(const std::string& s)
{
	std::wstring temp(s.length(), L' ');
	std::copy(s.begin(), s.end(), temp.begin());
	return temp;
}


std::string WStringToString(const std::wstring& s)
{
	std::string temp(s.length(), ' ');
	std::copy(s.begin(), s.end(), temp.begin());
	return temp;
}

void __stdcall my_puts(const char* str)
{
	fwrite(str, 1, strlen(str), stdout);
}

static console_output _pout = my_puts;

void DebugSetOutput(console_output pout)
{
	_pout = pout;
}

void DebugPrintf(const char* lpFormat, ...)
{
	CHAR buf[1024];
	va_list va;

	va_start(va, lpFormat);

	StringCbVPrintfA(buf, sizeof(buf), lpFormat, va);	

	_pout(buf);
}

std::wstring GetErrorMessage(DWORD dwError)
{
	LPWSTR pBuffer = NULL;

	DWORD dwSize = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS |
		FORMAT_MESSAGE_ALLOCATE_BUFFER, 0, dwError, 0, (LPWSTR)&pBuffer, 32 * 1024, nullptr);

	if (dwSize > 0)
	{
		std::wstring ret = pBuffer;

		LocalFree(pBuffer);

		return ret;
	}
	else
	{
		printf("Error getting message %d\n", GetLastError());
		WCHAR buf[64];
		StringCchPrintf(buf, _countof(buf), L"%d", dwError);
		return buf;
	}
}

std::wstring GetErrorMessage()
{
	return GetErrorMessage(GetLastError());
}


BOOL SetPrivilege(HANDLE hToken, LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)
{
	TOKEN_PRIVILEGES tp;
	LUID luid;

	if (!LookupPrivilegeValue(NULL, lpszPrivilege, &luid))
	{
		return FALSE;
	}

	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	if (bEnablePrivilege)
	{
		tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
	}
	else
	{
		tp.Privileges[0].Attributes = 0;
	}

	if (!AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), (PTOKEN_PRIVILEGES)NULL, (PDWORD)NULL))
	{
		return FALSE;
	}

	if (GetLastError() == ERROR_NOT_ALL_ASSIGNED)
	{
		return FALSE;
	}

	return TRUE;
}

DWORD NtStatusToDosError(NTSTATUS status)
{
	DEFINE_NTDLL(RtlNtStatusToDosError);
	return fRtlNtStatusToDosError(status);
}

void SetNtLastError(NTSTATUS status)
{
	SetLastError(NtStatusToDosError(status));
}

FARPROC GetProcAddressNT(LPCSTR lpName)
{
	return GetProcAddress(GetModuleHandleW(L"ntdll"), lpName);
}

HANDLE OpenFileNative(LPCWSTR path, HANDLE root, ACCESS_MASK desired_access, ULONG share_access, ULONG open_options)
{
	UNICODE_STRING name = { 0 };
	OBJECT_ATTRIBUTES obj_attr = { 0 };

	DEFINE_NTDLL(RtlInitUnicodeString);
	DEFINE_NTDLL(NtOpenFile);

	if (path)
	{
		fRtlInitUnicodeString(&name, path);
		InitializeObjectAttributes(&obj_attr, &name, OBJ_CASE_INSENSITIVE, root, nullptr);
	}
	else
	{
		InitializeObjectAttributes(&obj_attr, nullptr, OBJ_CASE_INSENSITIVE, root, nullptr);
	}

	HANDLE h = nullptr;
	IO_STATUS_BLOCK io_status = { 0 };
	NTSTATUS status = fNtOpenFile(&h, desired_access, &obj_attr, &io_status, share_access, open_options);
	if (NT_SUCCESS(status))
	{
		return h;
	}
	else
	{
		SetNtLastError(status);
		return nullptr;
	}
}

std::wstring BuildFullPath(const std::wstring& path, bool native)
{
	std::wstring ret;
	WCHAR buf[MAX_PATH];

	if (native)
	{
		ret = L"\\??\\";
	}

	if (GetFullPathName(path.c_str(), MAX_PATH, buf, nullptr) > 0)
	{
		ret += buf;
	}
	else
	{
		ret += path;
	}

	return ret;
}

std::wstring GetFileName(const std::wstring& s) {

	char sep = '/';

#ifdef _WIN32
	sep = '\\';
#endif

	size_t i = s.rfind(sep, s.length());
	if (i != std::string::npos) {
		return(s.substr(i + 1, s.length() - i));
	}

	return(L"");
}

std::wstring GetDirectoryName(const std::wstring& filename) {

	std::wstring directory = L"";
	const size_t last_slash_idx = filename.rfind('\\');
	if (std::string::npos != last_slash_idx)
	{
		directory = filename.substr(0, last_slash_idx);
	}

	return directory;
}